<!DOCTYPE html>
<html>

<head>
    <script src="http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"></script>
</head>

<body>

    <input class="username" type="text" name="string"/>

    <script type="text/javascript">
    // test git
    //1. Promise
    $(function() {
        // setTimeout(function(){
        //     console.log('1');
        // }, 1000)

        let p1 = new Promise(function(resolve, reject){
            setTimeout( () => resolve('1'), 3000 )
        })
        let p2 = new Promise(function(resolve, reject){
            setTimeout( () => resolve('2'), 2000 )
        })
        let p3 = new Promise(function(resolve, reject){
            setTimeout( () => resolve('3'), 1000 )
        })

        p1
            .then(result => {
                console.log(result);
                return p2;
            })
            .then(result => {
                console.log(result);
                return p3;
            })
            .then(result => {
                console.log(result);
            })
            // .catch(error => console.log(error))
    });


    // 2. async     在一堆异步执行的代码中创建了一块同步执行的代码区域快
    function timeDelay1(word){
        return new Promise((resolve) => {
            setTimeout( () => resolve(word + '1 '), 2000);
        })
        // setTimeout(() => {
        //     console.log('1');
        // }, 2000)
    }

    function timeDelay2(word){
        return new Promise((resolve) => {
            setTimeout(() => resolve(word + '2'), 1000);
        })
        // setTimeout(() => {
        //     console.log('2');
        // }, 1000)
    }

    async function sayYes(word){
        var a = await timeDelay1(word);
        // console.log(a)
        var b = await timeDelay2(a);
        console.log(b);
        console.log(word);
    }
    sayYes('yes');
    console.log('我最后')


    // 3.class
    class Point {
        // 构造函数
        constructor (x, y) {
            this.x = x;
            this.y = y;
        }
        // getter setter
        get x () {
            console.log('getter');
        }
        set x (value) {
            console.log('setter: ' + value);
        }
        // 静态方法(可以被继承)
        static sayHello () {
            console.log('Hello');
        }

        toSay() {
            return `(${this.x}, ${this.y})`;
        }
    }

    class Surface extends Point {
        constructor (x, y, z) {
            super(x, y);
            this.z = z;
        }

        toYell() {
            return this.z;
        }
    }

    var point = new Point(1, 2);
    // console.log(point.toSay());
    // point.prop = 1;
    // point.x;
    Point.sayHello();

    var surface = new Surface(1, 2, 3);
    // console.log(surface.toSay())
    // console.log(surface.toYell())
    Surface.sayHello();
    </script>
</body>

</html>
